Задача была задизайнить и оптимизировать под хардвейр уравнение Q = ( (a-b)*(1+3c)-4d ) / 2 .
Я задизайнил rtl этого уравнение максимально оптимизируя и используя все мои знания .
Вместо того чтобы делить на два простым путем "/ 2", что отнимает много циклов, я сделал шифт направо на 1 bit верхнего числителя .
Вместо того чтобы умножить 3 на с  и 4 на d, я 3 раза и 4 раза простые (+) аддеры использовал .
Тестовый стенд проверяет на 8 тестов каждый из них дает разные инпуты и в конце сравнивается expected Q с result Q, который посчитал наш Хардвейр
Пайтон те же самые тесты прогоняет и можно увидеть те же самые результаты

Возможные способы защиты и ошибок от переполнения разрядной сетки:
1) Выделять достаточное количество разрядов для всех вычеслений
2) Лимитить разрядность результата
3) Выводить оверфлоу флаги чтобы дальнейше уже справляться с оверфлоуом

Где я все ранил и компайлил? EDA Playground с инструментом Icarus и Python online compiler любой

На руках был инструмент Verilator но не стал рисковать тестбенч писать на С

Не было в наличии инструментальной возможности, но если пройду на стажировку обязательно куплю!

Спасибо всем!
